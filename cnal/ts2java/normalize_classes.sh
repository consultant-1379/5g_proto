#!/bin/bash
#
# Normalize all the Java class files that have been generated by the YAML-to-Java compiler.
# The YAML-to-Java compiler always generates all the Java classes that are defined in the YAML definition of a TS, including all referenced classes.
# This means that across all TSs, there are heaps of duplicate classes that should be moved to a common place for re-use.
# Duplicate classes are a problem for generic code as, from Java point of view, classes that are identical but in different packages are not the same. 
# This script will analyze the TSs and move all classes to the place they belong, according to what TS has defined a class.
#
# Synopsis: normalize_classes.sh <path-to-5g_proto>

#set -e # Any subsequent commands which fail will cause the shell script to exit immediately

pushd "${1:-.}/cnal/ts2java"

ROOT=tmp
META_DIR=$ROOT/meta
SRC_ROOT=$ROOT/src/main/java/com/ericsson/cnal/openapi/r17
DEST_ROOT=$ROOT/$SRC_ROOT

# Extract meta data from TS files.
#
prepare_meta_data.sh "$1" "${SRC_ROOT##$ROOT/src/main/java/}" "generation"

echo "$0: starting ..."

# Remove destination folder.
#
rm -rf $ROOT/$ROOT

# Copy all Java files in $SRC_ROOT to the same place in the destination folder.
#
mkdir -p "$DEST_ROOT"
cp -f "$SRC_ROOT"/*.java "$DEST_ROOT"

# Loop over all source files in the meta data.
# For each file in the meta folder:
# - Find the corresponding file in the source folder
# - Replace the imports related to the openapi by those in the meta file
# - Write the result to the destination folder.
#
for meta_file in `find $META_DIR -name "*.java"`
do
	src_file="$SRC_ROOT/"${meta_file##$META_DIR/}    # nnrf/nfdiscovery/AccessType.java

	if [ -f "$src_file" ]
	then
		imports=`cat "$meta_file"`
		dest_file="$ROOT/$src_file"
		dest_path=${dest_file%/*}

		mkdir -p $dest_path
		cat "$src_file" | awk -v imports="$imports" -f rewrite_class.awk > "$dest_file"
	fi
done

# Copy source files with class names generated by the compiler.
# These are class names that are not explicitly visible in the TSs.

for src_file in `find "$SRC_ROOT" -name "*Of.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

#for src_file in `find "$SRC_ROOT" -name "*Inner.java"`
#do
#	dest_file="$ROOT/$src_file"
#	dest_path=${dest_file%/*}
#	mkdir -p $dest_path
#	cp "$src_file" "$dest_file" 
#done

for src_file in `find "${SRC_ROOT}/ts29505/subscription/data" -name "OperatorSpecificDataContainerValue.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

for src_file in `find "${SRC_ROOT}/ts29509/nausf/ueauthentication" -name "UEAuthenticationCtx5gAuthData.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

for src_file in `find "${SRC_ROOT}/ts29510/nnrf/accesstoken" -name "AccessTokenClaimsAud.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

for src_file in `find "${SRC_ROOT}/ts29510/nnrf/accesstoken" -name "AccessTokenReq1.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "${dest_file/1//}" 
done

for src_file in `find "${SRC_ROOT}/ts29510/nnrf/nfmanagement" -name "Dnn*InfoItemDnn.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

for src_file in `find "${SRC_ROOT}/ts29510/nnrf/nfmanagement" -name "NrfInfoServed*Value.java"`
do
	dest_file="$ROOT/$src_file"
	dest_path=${dest_file%/*}
	mkdir -p $dest_path
	cp "$src_file" "$dest_file" 
done

# Remove non-existing imports from all Java classes.
#
for dest_file in `find "$DEST_ROOT" -name "*.java"`
do
	cat "$dest_file" | awk -v pkg_root="${SRC_ROOT##$ROOT/src/main/java/}" -f remove_non_ex_imports_from_class.awk  > "${dest_file}.tmp"
	mv "${dest_file}.tmp" "$dest_file"
done

popd

echo "$0: finished."

# Do post-processing on the generated Java classes.
#
post_process_classes.sh "$1"

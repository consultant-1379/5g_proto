#!/usr/bin/expect

################################################################################
#
#  Author   : eustone
#
#  Revision : 2.33
#  Date     : 2024-01-16 17:37:53
#
################################################################################
#
# (C) COPYRIGHT ERICSSON GMBH 2017-2024
#
# The copyright to the computer program(s) herein is the property of
# Ericsson GmbH, Germany.
#
# The program(s) may be used and/or copied only with the written permission
# of Ericsson GmbH in accordance with the terms and conditions stipulated in
# the agreement/contract under which the program(s) have been supplied.
#
################################################################################

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# ------------------------------- Procedures ----------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# Show syntax and help information.
# Input:
#  -
#
# Output:
#  -
#
proc show_syntax {} {
    global argv0

    #              1         2         3         4         5         6         7         8
    #     12345678901234567890123456789012345678901234567890123456789012345678901234567890
    puts "This script connects to the node (being either GEP OAM VIP, DMX/BSP NBI or even"
    puts "a Linux prompt) and executes one or more commands provided either on the"
    puts "command line or via a command file."
    puts ""
    puts "Then it executes one or more commands provided either on the command"
    puts "line or via a command file. The commands are executed in the order"
    puts "in which they have been specified. As an option, command execution"
    puts "can also stop if an error has been detected for a command in which"
    puts "case none of the remaining commands will be executed."
    puts ""
    puts "The script will only automatically send commands needed to connect to the node"
    puts "and to exit out of the connection."
    puts ""
    puts "If the command to be sent contains the following string on one line then the"
    puts "behavior will change according to this:"
    puts ""
    puts "  @@AFTER_MS=<milliseconds>"
    puts "    Add a delay of the specified number of milliseconds before continuing with"
    puts "    next command."
    puts ""
    puts "  @@DO_NOT_HIDE_COMMAND_ECHO"
    puts "    Start showing the commands again."
    puts ""
    puts "  @@DO_NOT_HIDE_COMMAND_OUTPUT"
    puts "    Start showing the command output again."
    puts ""
    puts "  @@DO_NOT_IGNORE_ERRORS"
    puts "    Start checking for errors in the commands again."
    puts ""
    puts "  @@HIDE_COMMAND_ECHO"
    puts "    The command will not be shown in the output, but all data from the command"
    puts "    will still be shown in the output."
    puts "    This might be useful when the command contains a password that should not"
    puts "    be visible."
    puts "    Any commands entered up until the next @@DO_NOT_HIDE_COMMAND_ECHO will also"
    puts "    have it's command hidden."
    puts ""
    puts "  @@HIDE_COMMAND_OUTPUT"
    puts "    The command and all it's data will not be shown in the output, but all data"
    puts "    from the command will still be shown in the output."
    puts "    This might be useful when the command and it's output contains sensitive data"
    puts "    that should not be visible but the command should still be executed."
    puts "    Any commands entered up until the next @@DO_NOT_HIDE_COMMAND_OUTPUT will also"
    puts "    have it's output hidden."
    puts ""
    puts "  @@IGNORE_ERRORS"
    puts "    Ignore any errors generated by the commands and treat them as successful up"
    puts "    until the next @@DO_NOT_IGNORE_ERRORS."
    puts ""
    puts "  @@PROMPT_DETECT_TIMEOUT=<seconds>"
    puts "    Change the prompt detection timeout from the default 1 second to some other"
    puts "    higher value for the following commands."
    puts "    See details for parameter --prompt-detect-timeout."
    puts ""
    puts ""
    puts "syntax:"
    puts "======="
    puts ""
    puts "  $argv0 <mandatory> <optional>"
    puts ""
    puts "<mandatory> is:"
    puts "   --ip=<IP address to the node via SSH>"
    puts "   --user=<username for login>        (Not needed when --ip=localhost)"
    puts "   --password=<password for login>    (Not needed when --ip=localhost)"
    puts "    and one or more of:"
    puts "   --command=<command to send>"
    puts "   --command-file=<filename containing commands to send>"
    puts ""
    puts "<optional> is one or more of the following:"
    puts "  --advanced-password=<password>"
    puts "  --debug"
    puts "  --fake-term=<string>"
    puts "  --help"
    puts "  --ignore-errors"
    puts "  --log-append"
    puts "  --log-file=<log file path>"
    puts "  --new-password=<new password for login>"
    puts "  --no-term-change"
    puts "  --port=<port number>"
    puts "  --prompt-detect-timeout=<seconds>"
    puts "  --replace-managedelement"
    puts "  --root-access"
    puts "  --root-password=<password>"
    puts "  --shell=(cliss|dsc-connect-signalling-mgr|netconf|signmcli)"
    puts "  --show-commands-to-send"
    puts "  --stop-on-error"
    puts "  --target-blade=<blade name>"
    puts "  --timeout=<seconds>"
    puts ""
    puts "Where:"
    puts ""
    puts "  --advanced-password=<password>"
    puts "    Set the password to be used when login to the node with user 'advanced'."
    puts "    Default is 'ett,30' if not specified."
    puts ""
    puts "  --command=<command to send>"
    puts "    This parameter specifies the command to send to the node and the parameter"
    puts "    can be specified multiple times and also in combination with the --command-file"
    puts "    parameter. The order of the commands to be sent will be determined by the order"
    puts "    of the parameters."
    puts ""
    puts "  --command-file=<filename containing commands to send>"
    puts "    This parameter specifies the command file to send to the node and the parameter"
    puts "    can be specified multiple times and also in combination with the --command"
    puts "    parameter. The order of the commands to be sent will be determined by the order"
    puts "    of the parameters."
    puts ""
    puts "  --debug"
    puts "    Shows extra debug messages."
    puts ""
    puts "  --fake-term=<string>"
    puts "    If this parameter is specified then the environment variable TERM will be updated"
    puts "    to the value specified with the <string> value before connecting to the remote node."
    puts "    In certain cases when connecting to a node from some automated tool like a SUF server"
    puts "    where the terminal might be set to the value 'dumb' then it causes issues when"
    puts "    sending commands to the CLISS shell and no data is returned. But by faking e.g. an"
    puts "    'xterm' terminal by parameter '--fake-term=xterm' then commands execute normally."
    puts "    If this parameter is not specified and --no-term-change is also not specified then"
    puts "    the environment variable TERM is set to 'xterm'."
    puts "    The parameter --no-term-change has higher priority than this parameter."
    puts ""
    puts "  --help"
    puts "    Shows this help information."
    puts ""
    puts "  --ignore-errors"
    puts "    If specified then any errors generated from the sent commands will simply"
    puts "    be ignored, the default is to treat every error to a sent command as a failure."
    puts "    This can also be controlled from the command to send by using one of the"
    puts "    following commands:"
    puts "    @@IGNORE_ERRORS"
    puts "    @@DO_NOT_IGNORE_ERRORS"
    puts ""
    puts "  --ip=<IP address to the node via SSH>"
    puts "    Set the IP-address to use for connecting to the node, the connection is"
    puts "    done using the SSH protocol."
    puts "    If '--ip=localhost' is used then a new bash shell is started instead of starting."
    puts "    an ssh process."
    puts ""
    puts "  --log-append"
    puts "    If specified then any output is appended to an existing log file, the"
    puts "    default is to overwrite the log file."
    puts ""
    puts "  --log-file=<log file path>"
    puts "    If specified then output from executed commands are logged to the specified"
    puts "    log file. The directory path must exist and it must be possible to write to"
    puts "    the file."
    puts ""
    puts "  --new-password=<new password for login>"
    puts "    If specified and the node asks to change the password by the following"
    puts "    prompts then this parameter will be used as the new password:"
    puts "       Password:"
    puts "       Password expired. Change your password now."
    puts "       Current Password:"
    puts "       New Password:"
    puts "       Reenter new Password:"
    puts ""
    puts "  --no-term-change"
    puts "    If this parameter is specified then the environment variable TERM will not be updated"
    puts "    so if already set it will keep it's original value."
    puts "    See also parameter --fake-term."
    puts "    This parameter has higher priority than the --fake-term parameter."
    puts ""
    puts "  --password=<password for login>"
    puts "    Set the user password to use for connecting to the node, the connection is"
    puts "    done using the SSH protocol."
    puts "    Not needed if '--ip=localhost' is used."
    puts ""
    puts "  --port=<port number>"
    puts "    Set the port number to use for connecting to the node."
    puts "    If not specified then the default value used would be '22'."
    puts ""
    puts "  --prompt-detect-timeout=<seconds>"
    puts "    Set the timeout value to use for detecting a new prompt."
    puts "    The default value if not set will be 1 second meaning that if there is data coming"
    puts "    from the node that contains no LF (line feed) character then a timer will be started"
    puts "    with the value specified with this parameter, and if there are no more characters"
    puts "    coming before the timer expire then it's assumed that we have received a new prompt"
    puts "    (that was not expected) from the node and we should continue to execute the next"
    puts "    command, if any."
    puts "    A new prompt can e.g. happen when a command like 'cd' is executed."
    puts "    "
    puts "    In certain cases e.g. when the node prints some kind of progress messages like a . (dot)"
    puts "    or other character every few seconds to show that a command is still in progress then"
    puts "    it might be needed to extent the prompt detect timeout from the default 1 second to"
    puts "    something higher to avoid having incorrect detection of a prompt which might cause"
    puts "    a promlem where a command is sent too early or cause premature termination of the"
    puts "    command execution resulting in a failure."
    puts ""
    puts "  --replace-managedelement"
    puts "    If specified it will replace any occurance of the string 'ManagedElement=1'"
    puts "    in the sent commands with the real element name."
    puts "    This parameter only make sense if the connection is towards the CLISS shell."
    puts ""
    puts "  --root-access"
    puts "    if specified then a switch to root account is done before sending commands."
    puts ""
    puts "  --root-password=<password>"
    puts "    Set the password to be used when login to the node with user 'root'."
    puts "    Default is 'rootroot' or 'tre,14' if not specified."
    puts ""
    puts "  --shell=(cliss|dsc-connect-signalling-mgr|netconf|signmcli)"
    puts "    Connect to a specific shell after connection to node has been established."
    puts ""
    puts "  --show-commands-to-send"
    puts "    If specified then all commands to be executed will be printed before"
    puts "    execution starts."
    puts ""
    puts "  --stop-on-error"
    puts "    If specified and a command results in an error then execution of all"
    puts "    following commands will not take place."
    puts "    by default if this parameter is not specified then execution will"
    puts "    continue with all commands even if errors are detected."
    puts ""
    puts "  --target-blade=<blade name>"
    puts "    If specified then after connecting to the wanted node it will first connect"
    puts "    to the specified blade before executing any of the commands."
    puts "    This parameter can be useful e.g. if you initially connect to the SC-1 IP-address"
    puts "    but all the commands should be executed on the PL-3 blade."
    puts "    It can also be used to connect to the active controller by giving <blade name>"
    puts "    the value 'activecontroller'"
    puts "    Example: --target-blade=sc-2"
    puts "             --target-blade=activecontroller"
    puts ""
    puts "  --timeout=<seconds>"
    puts "    Set the timeout value to use when sending a command to the node before a"
    puts "    printout is returned back by the node."
    puts "    If nothing is returned back from the node within this time frame or"
    puts "    if the node prompt is not returned back after the last printout then it"
    puts "    is considered as a failure."
    puts "    For long executing commands that takes longer than the default (1200) seconds"
    puts "    to produce any printouts, set this parameter to a higher value."
    puts "    Default is '1200' seconds if not specified."
    puts ""
    puts "  --user=<username for login>"
    puts "    Set the user name to use for connecting to the node, the connection is"
    puts "    done using the SSH protocol."
    puts "    Not needed if '--ip=localhost' is used."
    puts ""
    puts ""
    puts "Examples:"
    puts "========="
    puts ""
    puts "Example 1:"
    puts "Send command to DMX."
    puts ""
    puts "  $argv0 --user=expert --ip=10.87.80.116 --password='expert' --port=2024 --command='show configuration|nomore'"
    puts ""
    puts ""
    puts "Example 2:"
    puts "Send command to BSP CLISS."
    puts ""
    puts "  $argv0 --user=advanced --ip=10.87.80.116 --password='ett,30' --port=2024 --command='show all'"
    puts ""
    puts ""
    puts "Example 3:"
    puts "Send command to GEP CLISS."
    puts ""
    puts "  $argv0 --user=root --ip=10.87.80.116 --password='rootroot' --port=830 --shell=cliss --command='show-config'"
    puts ""
    puts ""
    puts "Example 4:"
    puts "Send command to GEP Signalling Manager CLI."
    puts ""
    puts "  $argv0 --user=root --ip=10.87.80.116 --password='rootroot' --port=830 --shell=dsc-connect-signalling-mgr --command='printall;'"
    puts "     or"
    puts "  $argv0 --user=root --ip=10.87.80.116 --password='rootroot' --port=830 --shell=signmcli --command='printall;'"
    puts ""
    puts ""
    puts "The script returns:"
    puts "==================="
    puts ""
    puts " 0: Successful termination"
    puts " 1: Unsuccessful termination"
    puts " 2: Unsuccessful login"
    puts ""
}

source [file join [file dirname [info script]] ../lib/_CLISS_get_ManagedElement_name.exp]
source [file join [file dirname [info script]] ../lib/_CLISS_send_command.exp]
source [file join [file dirname [info script]] ../lib/_CMYP_send_command.exp]
source [file join [file dirname [info script]] ../lib/_DMX_send_command.exp]
source [file join [file dirname [info script]] ../lib/_error_message.exp]
source [file join [file dirname [info script]] ../lib/_exit_all.exp]
source [file join [file dirname [info script]] ../lib/_exit_with_error_message.exp]
source [file join [file dirname [info script]] ../lib/_GEP_connect_to_node.exp]
source [file join [file dirname [info script]] ../lib/_GEP_connect_to_primary_sc.exp]
source [file join [file dirname [info script]] ../lib/_GEP_send_command.exp]
source [file join [file dirname [info script]] ../lib/_GEP_start_cliss.exp]
source [file join [file dirname [info script]] ../lib/_GEP_start_signmcli.exp]
source [file join [file dirname [info script]] ../lib/_GEP_su_root.exp]
source [file join [file dirname [info script]] ../lib/_get_shell_type.exp]
source [file join [file dirname [info script]] ../lib/_login_via_bash.exp]
source [file join [file dirname [info script]] ../lib/_login_via_ssh.exp]
source [file join [file dirname [info script]] ../lib/_NETCONF_send_command.exp]
source [file join [file dirname [info script]] ../lib/_SIGNMCLI_send_command.exp]
source [file join [file dirname [info script]] ../lib/_UNIX_send_command.exp]
source [file join [file dirname [info script]] ../lib/_UNIX_su_root.exp]


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# ----------------------------- Main code loop --------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------


# increased the default timeout to 1200 in order to let the long-running MAPIWF extension execute
# Set timeout value in seconds to use for waiting for the expected string
set timeout 1200

# Initialize the global error counter
set errorcnt 0

# Initialize debug_list for the scripts that need it
set debug_list {}

set advanced_password ""
set command ""
set command_list {}
set command_output_list {}
set debug_messages 0
set detected_prompt ""
set detected_prompt_raw ""
set element_name ""
set error_line ""
set fake_term "xterm"
set filename ""
set hide_command_echo 0
set hide_command_output 0
set ignore_errors 0
set ip ""
set log_append 0
set log_filename ""
set new_password ""
set no_term_change 0
set shell ""
set param ""
set password ""
set port ""
set prompt_detect_timeout 1
set replace_managedelement 0
set root_password ""
set shell_type ""
set show_commands_to_send 0
set stop_on_error 0
set switch_to_root 0
set target_blade ""
set user ""

# Parse specific command line parameters
foreach cmd_arg $argv {
    append all_args $cmd_arg " "

    # --shell=
    if {[regexp "^(\-\-shell)=(.+)" $cmd_arg junk param value] == 1} {
        set shell $value

    }
}
if {$shell != ""} {
    if {$shell == "cliss"} {
        # Connect to GEP CLISS
    } elseif {$shell == "dsc-connect-signalling-mgr"} {
        # Connect to GEP signaling manager (new way)
    } elseif {$shell == "netconf"} {
        # Connect to NETCONF
    } elseif {$shell == "signmcli"} {
        # Connect to GEP signaling manager (old way)
    } else {
        exit_with_error_message 1 "Not supported shell type in parameter --shell, allowed values are (cliss|dsc-connect-signalling-mgr|netconf|signmcli)"
    }
}

# Parse all command line parameters
foreach cmd_arg $argv {
    append all_args $cmd_arg " "

    # --help
    if {[regexp "^(\-\-help)$" $cmd_arg junk param] == 1} {
        show_syntax
        exit 1

    # --advanced-password=
    } elseif {[regexp "^(\-\-advanced-password)=(.+)" $cmd_arg junk param value] == 1} {
        set advanced_password $value

    # --command=
    } elseif {[regexp "^(\-\-command)=(.+)" $cmd_arg junk param value] == 1} {
        lappend command_list $value

    # --command-file=
    } elseif {[regexp "^(\-\-command-file)=(.+)" $cmd_arg junk param value] == 1} {
        set command_file $value
        #lappend command_list ""
        set fh [open $command_file r]
        if {$shell != "netconf"} {
            # Append line by line from the file to command_list
            while {[gets $fh command] != -1} {
                lappend command_list $command
            }
        } else {
            # Append the whole file content as one line to command_list
            lappend command_list [read $fh]
        }
        close $fh

    # --debug
    } elseif {[regexp "^(\-\-debug)$" $cmd_arg junk param] == 1} {
        set debug_messages 1

    # --fake-term=
    } elseif {[regexp "^(\-\-fake-term)=(.+)" $cmd_arg junk param value] == 1} {
        set fake_term $value

    # --ignore-errors
    } elseif {[regexp "^(\-\-ignore-errors)$" $cmd_arg junk param] == 1} {
        set ignore_errors 1

    # --ip=
    } elseif {[regexp "^(\-\-ip)=(.+)" $cmd_arg junk param value] == 1} {
        set ip $value

    # --log-append
    } elseif {[regexp "^(\-\-log-append)$" $cmd_arg junk param] == 1} {
        set log_append 1

    # --log-file=
    } elseif {[regexp "^(\-\-log-file)=(.+)" $cmd_arg junk param value] == 1} {
        set log_filename $value

    # --new-password=
    } elseif {[regexp "^(\-\-new-password)=(.+)" $cmd_arg junk param value] == 1} {
        set new_password $value

    # --no-term-change
    } elseif {[regexp "^(\-\-no-term-change)$" $cmd_arg junk param] == 1} {
        set no_term_change 1
        set fake_term ""

    # --password=
    } elseif {[regexp "^(\-\-password)=(.+)" $cmd_arg junk param value] == 1} {
        set password $value

    # --port=
    } elseif {[regexp "^(\-\-port)=(.+)" $cmd_arg junk param value] == 1} {
        set port $value

    # --prompt-detect-timeout=
    } elseif {[regexp "^(\-\-prompt-detect-timeout)=(.+)" $cmd_arg junk param value] == 1} {
        set prompt_detect_timeout $value

    # --replace-managedelement
    } elseif {[regexp "^(\-\-replace-managedelement)$" $cmd_arg junk param] == 1} {
        set replace_managedelement 1

    # --root-access
    } elseif {[regexp "^(\-\-root-access)$" $cmd_arg junk param] == 1} {
        set switch_to_root 1

    # --root-password=
    } elseif {[regexp "^(\-\-root-password)=(.+)" $cmd_arg junk param value] == 1} {
        set root_password $value

    # --shell=
    } elseif {[regexp "^(\-\-shell)=(.+)" $cmd_arg junk param value] == 1} {
        # Ignore this parameter, already handled in loop above

    # --show-commands-to-send
    } elseif {[regexp "^(\-\-show-commands-to-send)$" $cmd_arg junk param] == 1} {
        set show_commands_to_send 1

    # --stop-on-error
    } elseif {[regexp "^(\-\-stop-on-error)$" $cmd_arg junk param] == 1} {
        set stop_on_error 1

    # --target-blade=
    } elseif {[regexp "^(\-\-target-blade)=(.+)" $cmd_arg junk param value] == 1} {
        set target_blade $value
        # puts "\t$param seen with $value"

    # --timeout=
    } elseif {[regexp "^(\-\-timeout)=(.+)" $cmd_arg junk param value] == 1} {
        set timeout $value

    # --user=
    } elseif {[regexp "^(\-\-user)=(.+)" $cmd_arg junk param value] == 1} {
        set user $value

    } else {
        exit_with_error_message 1 "Unknown parameter \"$cmd_arg\" detected, use parameter --help to see syntax"
    }
}

# Check consistency of the parameters
if { $ip == "localhost" } {
    # No need for user and password check
} elseif {$ip != ""} {
    if {$user == ""} {
        exit_with_error_message 1 "Missing parameter --user="
    }
    if {$password == ""} {
        exit_with_error_message 1 "Missing parameter --password="
    }
} else {
    exit_with_error_message 1 "Missing parameter --ip="
}
if {[llength $command_list] == 0} {
    exit_with_error_message 1 "You must specify at least one command with --command= or --command-file="
}
if { $switch_to_root == 1 } {
    if { $root_password == "" } {
        exit_with_error_message 1 "Missing parameter --root-password=, must be specifed when --root-access given"
    }
}

# Workaround for problem which happens when this script is run as part of the
# DAFT server playlist which runs the script using a terminal type "dumb" which
# causes the CLISS to not show any prompt which causes all sent commands to
# time out.
# The workaround is to trick the terminal to use a terminal type of "xterm" which
# at least seems to return back a proper CLISS prompt.
if { $no_term_change == 0 } {
    if { $fake_term != "" } {
        set env(TERM) $fake_term
    } elseif { $shell == "cliss" } {
        # For backwards compatibility we still fake xterm when connecting to cliss
        set env(TERM) "xterm"
    }
}

# Connect to the node
if { $ip == "localhost" } {
    if {[login_via_bash] > 0} {
        exit_with_error_message 2 "Unable to start a new bash shell"
    }
} elseif { $ip == "CHANGEME" } {
    if {[login_via_bash] > 0} {
        exit_with_error_message 2 "Unable to start a new bash shell"
    }
} elseif { $ip == "NOTUSED" } {
    if {[login_via_bash] > 0} {
        exit_with_error_message 2 "Unable to start a new bash shell"
    }
} else {
    if {[login_via_ssh $ip $user $password $port $new_password] > 0} {
        # Some error have occurred
        if { $port != "" } {
            exit_with_error_message 2 "Unable to login to node via SSH at IP address $ip and port $port"
        } else {
            exit_with_error_message 2 "Unable to login to node via SSH at IP address $ip"
        }
    }
}

if {$shell == "netconf"} {
    # We cannot check shell type using the normal method since sending
    # an empty line to netconf returns nothing, so we just say it's a
    # netconf shell type.
    set shell_type "NETCONF"
} else {
    # Determine what kind of shell we have connected to
    set shell_type [get_shell_type]
}

if {$shell_type == "CLISS"} {
    # BSP 8100 or GEP CLISS
    # Nothing more to do
} elseif {$shell_type == "DMX"} {
    # DMX
    # Nothing more to do
} elseif { $shell_type == "GEP-LINUX" } {
    # GEP Linux

    # Check if we need to first connect to another blade
    if { $target_blade == "activecontroller" } {
        if { [GEP_connect_to_primary_sc "$password"] != 0 } {
            incr errorcnt
            exit_all
            exit_with_error_message 1 "Unable to connect to active controller"
        }
    } elseif { $target_blade != "" } {
        if { [GEP_connect_to_node $target_blade $password] != 0 } {
            incr errorcnt
            exit_all
            exit_with_error_message 1 "Unable to connect to target blade at $target_blade"
        }
    }

    # Check if we need to switch to root account
    if { $switch_to_root == 1 } {
        # Switch to root account
        if { [GEP_su_root "$root_password"] > 0 } {
            # Some error have occurred
            exit_all
            exit_with_error_message 1 "Unable to switch to root account"
            exit 1
        }
    }

    # Remove nasty colors by redefining the PS1 prompt
    GEP_send_command "export PS1='\\h:\\w \\$ '"

    if {$shell == "cliss"} {
        # Connect to GEP CLISS
        if {[GEP_start_cliss $password] != 0} {
            exit_all
            exit_with_error_message 1 "Unable to login to CLISS"
        }
        set shell_type "CLISS"
    } elseif {$shell == "dsc-connect-signalling-mgr"} {
        # Connect to signaling manager
        if {[GEP_start_signmcli] != 0} {
            exit_all
            exit_with_error_message 1 "Unable to login to Signalling Manager CLI"
        }
        set shell_type "GEP-SIGNMCLI"
    } elseif {$shell == "signmcli"} {
        # Connect to signaling manager
        if {[GEP_start_signmcli] != 0} {
            exit_all
            exit_with_error_message 1 "Unable to login to Signalling Manager CLI"
        }
        set shell_type "GEP-SIGNMCLI"
    }
} elseif {$shell_type == "LINUX"} {
    # Some LINUX server, e.g. DAFT server

    # Check if we need to switch to root account
    if { $switch_to_root == 1 } {
        # Switch to root account
        if { [UNIX_su_root "$root_password"] > 0 } {
            # Some error have occurred
            exit_all
            exit_with_error_message 1 "Unable to switch to root account"
            exit 1
        }
    }

    # Remove nasty colors by redefining the PS1 prompt
    # UNIX_send_command "export PS1='\\h:\\w \\$ '"

} elseif {$shell_type == "CYGWIN"} {
    # Some Windows machine running Cygwin LINUX emulation

    # Check if we need to switch to root account
    if { $switch_to_root == 1 } {
        # Switch to root account
        if { [UNIX_su_root "$root_password"] > 0 } {
            # Some error have occurred
            exit_all
            exit_with_error_message 1 "Unable to switch to root account"
            exit 1
        }
    }

} elseif {$shell_type == "DIRECTOR-LINUX"} {
    # The director of the SC node

    # Check if we need to switch to root account
    if { $switch_to_root == 1 } {
        # Switch to root account
        if { [UNIX_su_root "$root_password"] > 0 } {
            # Some error have occurred
            exit_all
            exit_with_error_message 1 "Unable to switch to root account"
            exit 1
        }
    }

    # Remove nasty colors by redefining the PS1 prompt
    # UNIX_send_command "export PS1='\\h:\\w \\$ '"

} elseif {$shell_type == "NETCONF"} {
    # NETCONF
    # Nothing more to do

} elseif {$shell_type == "CMYP-CLI"} {
    # CMYP CLI shell prompt
    # Nothing more to do

} else {
    # CMXB-LINUX
    # DMX
    # GEP-SIGNMCLI
    # ISS
    # SCXB-LINUX-DMX
    # SCXB-LINUX-BSP
    # UNKNOWN
    exit_all
    exit_with_error_message 1 "Unable to determine the shell type or not supported shell type ($shell_type)"
}

if {$shell_type == "CLISS"} {
    # BSP 8100 or GEP CLISS
    if {$replace_managedelement == 1} {
        set element_name [CLISS_get_ManagedElement_name]
        if {$element_name == ""} {
            exit_all
            exit_with_error_message 1 "Unable to find ManagedElement name"
        }
    }
}

# Check if commands to send should be displayed to user
if {$show_commands_to_send == 1} {
    puts "\nCommands to be sent are the following:"
    foreach command $command_list {
        puts "$command"
    }
    puts ""
}

# Check if we should log output to a file
if { $log_filename != "" } {
    if { $log_append == 1 } {
        # Append to existing file
        log_file $log_filename
    } else {
        # Overwrite any existing file
        log_file -noappend $log_filename
    }
}

# Execute all commands on the CMXB COM CLI
set linecnt 0
foreach command $command_list {
    # Remove white spaces from beginning and end
    set command [string trimleft [string trimright $command]]

    # Ignore comment lines and empty lines
    if { [regexp "^\[ \t\]*#.*" $command] == 1 } {
        # This is a comment line, ignore it
        incr linecnt
        continue
    } elseif { [string length $command] == 0 } {
        # This is an empty line, ignore it
        incr linecnt
        continue
    } elseif {[regexp "^\@\@AFTER_MS=(.+)" $command junk value] == 1} {
        # Start a delay with the specified number of milliseconds
        after $value
        continue
    } elseif { $command == "@@IGNORE_ERRORS" } {
        # This is a special marker to tell us to ignore errors from this point on
        set ignore_errors 1
        continue
    } elseif { $command == "@@DO_NOT_IGNORE_ERRORS" } {
        # This is a special marker to tell us to stop for errors from this point on
        set ignore_errors 0
        continue
    } elseif { $command == "@@HIDE_COMMAND_ECHO" } {
        # This is a special marker to tell us to hide the echoed command so it does not show up in the output
        # which might be useful if the command includes a password that should not be visible in the output.
        set hide_command_echo 1
        continue
    } elseif { $command == "@@DO_NOT_HIDE_COMMAND_ECHO" } {
        # This is a special marker to tell us to again show the echoed command so it does shows up in the output.
        set hide_command_echo 0
        continue
    } elseif { $command == "@@HIDE_COMMAND_OUTPUT" } {
        # This is a special marker to tell us to hide all output from the command so it does not show up in the output.
        log_user 0
        set hide_command_output 1
        continue
    } elseif { $command == "@@DO_NOT_HIDE_COMMAND_OUTPUT" } {
        # This is a special marker to tell us to again show all output from the command.
        if { $hide_command_output == 1 } {
            # It's strange here I cannot use "-nonewline" to get the prompt printed, if used then no prompt is printed
            # so have to print a new empty line to get the prompt printed which means the next command sent will be on
            # a new line by itself.
            puts ""
        }
        log_user 1
        set hide_command_output 0
        continue
    } elseif {[regexp "^\@\@PROMPT_DETECT_TIMEOUT=(.+)" $command junk value] == 1} {
        # Change the prompt detection timeout value from the default
        set prompt_detect_timeout $value
        continue
    }

    if { $hide_command_output == 1 } {
        puts "***** Hidden Command and it's Output *****"
    }

    # Execute the command
    if {$shell_type == "CLISS"} {
        if { $replace_managedelement == 1 } {
            # Replace all intances of "ManagedElement=1" with real element name
            set command [string map -nocase [ list "ManagedElement=1" "ManagedElement=$element_name" ] $command]
        }
        set result [CLISS_send_command $command]
    } elseif {$shell_type == "GEP-SIGNMCLI"} {
        set result [SIGNMCLI_send_command $command]
    } elseif {$shell_type == "DMX"} {
        set result [DMX_send_command $command]
    } elseif {$shell_type == "GEP-LINUX"} {
        set result [GEP_send_command $command]
    } elseif {$shell_type == "LINUX"} {
        set result [UNIX_send_command $command $hide_command_echo]
    } elseif {$shell_type == "CYGWIN"} {
        set result [UNIX_send_command $command $hide_command_echo]
    } elseif {$shell_type == "DIRECTOR-LINUX"} {
        set result [UNIX_send_command $command $hide_command_echo]
    } elseif {$shell_type == "NETCONF"} {
        set result [NETCONF_send_command $command]
    } elseif {$shell_type == "CMYP-CLI"} {
        set result [CMYP_send_command $command]
    }

    # Check the result of command execution
    if { $result == -1 } {
        # A timout occurred, report it as an error and get out
        incr errorcnt
        # Close any log file that was opened
        if { $log_filename != "" } {
            log_file
        }
        exit_with_error_message 1 "A timeout occurred while sending command \"$command\""

    } elseif { $result == -2 } {
        # The connection was lost
        if {$command == "exit"} {
            # Special handling because the command 'exit' can also drop the connection to the node
            if {$errorcnt > 0} {
                exit_with_error_message 1 "Error Counter = $errorcnt"
            } else {
                # TODO: Maybe we need to check if there are any commands left to send and in such case exit with an error
                puts "The connection to the node was lost after sending an \"exit\" command, we treat this as OK"
                # Close any log file that was opened
                if { $log_filename != "" } {
                    log_file
                }
                exit 0
            }
        } elseif {$shell_type == "NETCONF"} {
            # Special handling for NETCONF, since we send everything in one go i.e. 1 command
            # we assume everything is just fine when we lost the connection.
            # Because the logic inside NETCONF_send_command will return an error >1
            # if an error was detected or return a 0 if any <ok> was detected.
            # The proper solution would of course be to send each command by itself
            # instead of sending everything in one go, but that would require some
            # more logic above to separate each command (ending with ]]>]]>) into
            # it's own command line and send them one by one, but that might cause
            # other issues where there might not be any "prompt" sent back for some
            # commands.
            puts "The connection to the node was lost after sending all NETCONF data in one go.\nThis is most likely the expected behavior and we treat this as OK."
            # Close any log file that was opened
            if { $log_filename != "" } {
                log_file
            }
            exit 0
        } else {
            # The connection was lost, report it as an error and get out
            incr errorcnt
            # Close any log file that was opened
            if { $log_filename != "" } {
                log_file
            }
            exit_with_error_message 1 "The connection to the node was lost while sending command \"$command\""
        }

    } elseif { $ignore_errors == 1 } {
        # Ignore any kind of error, except for timeouts

    } elseif { $result > 0 } {
        # the command gave an error, step the error counter
        incr errorcnt $result
        error_message "\nAn error occurred while sending command:\n----------------------------------------\n$command\n----------------------------------------\n"
        if { $stop_on_error == 1 } {
            incr linecnt
            # Show already executed commands
            if { $linecnt > 1 } {
                puts "\nSuccessfully executed commands:\n-------------------------------"
                set i 1
                foreach command $command_list {
                    if {$i < $linecnt} {
                        puts "$command"
                    }
                    incr i
                }
                puts "-------------------------------\n"
            }

            # Show not executed commands
            set length [llength $command_list]
            if { $linecnt < $length } {
                puts "\nCommands not yet executed:\n--------------------------"
                set i 1
                foreach command $command_list {
                    if {$i > $linecnt} {
                        puts "$command"
                    }
                    incr i
                }
                puts "--------------------------\n"
            }
            break
        }
    }
    incr linecnt

    if { $hide_command_output == 1 } {
        puts -nonewline $detected_prompt_raw
    }
}

# Close any log file that was opened
if { $log_filename != "" } {
    log_file
}

# Time to exit out of the node, send exit or end until the connection is dropped
# but don't do it when connected to NETCONF
if {$shell_type != "NETCONF"} {
    exit_all
}

# Check for any errors
if {$errorcnt > 0} {
    exit_with_error_message 1 "Error Counter = $errorcnt"
} else {
    puts ""
    if { $debug_messages == 1 } {
        if { [info exists debug_list] } {
            if { [llength $debug_list] > 0 } {
                puts "\nThe information printed below can be used as trouble shooting help to find out why the script failed but is probably only useful for the developers of the script.\nThe following events has been seen:"
                puts "-----------------------------------------------------"
                foreach line $debug_list {
                    puts "$line"
                }
                puts "-----------------------------------------------------"
                puts ""
            }
        }
    }
    exit 0
}
